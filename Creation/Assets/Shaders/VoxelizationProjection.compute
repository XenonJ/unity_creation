// VoxelizeProjection.compute
// GPU “三向投影”体素化 Compute Shader

#pragma kernel CS_Clear
#pragma kernel CS_ProjectX
#pragma kernel CS_ProjectY
#pragma kernel CS_ProjectZ
#pragma kernel CS_Combine

// 三角形顶点数据，每三个 float3 为一三角形
StructuredBuffer<float3> _TriangleVerts;
uint                   _TriangleCount;

// AABB 范围和体素分辨率
float3 _AABBMin;
float3 _AABBMax;
int3   _SplitCount;    // {Nx, Ny, Nz}

// 投影图：0/1 标记
RWTexture2D<uint> _ProjYZ;  // 大小 Ny×Nz
RWTexture2D<uint> _ProjXZ;  // 大小 Nx×Nz
RWTexture2D<uint> _ProjXY;  // 大小 Nx×Ny

// 最终体素化结果
RWTexture3D<uint> _Volume;  // 大小 Nx×Ny×Nz

// 体素位置
AppendStructuredBuffer<float3> _VoxelPositions;

// Möller–Trumbore 三角形相交测试
bool RayTriangleIntersect(
    float3 orig, float3 dir,
    float3 v0, float3 v1, float3 v2)
{
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 pvec  = cross(dir, edge2);
    float   det  = dot(edge1, pvec);
    if (abs(det) < 1e-5) return false;
    float invDet = 1.0 / det;
    float3 tvec  = orig - v0;
    float   u    = dot(tvec, pvec) * invDet;
    if (u < 0 || u > 1) return false;
    float3 qvec  = cross(tvec, edge1);
    float   v    = dot(dir, qvec) * invDet;
    if (v < 0 || u + v > 1) return false;
    float   t    = dot(edge2, qvec) * invDet;
    return t > 0;
}

[numthreads(8,8,8)]
void CS_Clear(uint3 id : SV_DispatchThreadID)
{
    // 清空体素 & 投影缓冲
    _Volume[id] = 0;
    if (id.z == 0) {
        _ProjYZ[uint2(id.y, id.z)] = 0;
        _ProjXZ[uint2(id.x, id.z)] = 0;
    }
    if (id.y == 0) {
        _ProjXY[uint2(id.x, id.z)] = 0;
    }
}

[numthreads(8,8,1)]
void CS_ProjectX(uint3 id : SV_DispatchThreadID)
{
    // id.x = y ∈ [0,Ny), id.y = z ∈ [0,Nz)
    int y = id.x;
    int z = id.y;
    float yWorld = lerp(_AABBMin.y, _AABBMax.y, (y + 0.5) / _SplitCount.y);
    float zWorld = lerp(_AABBMin.z, _AABBMax.z, (z + 0.5) / _SplitCount.z);
    float3 orig = float3(_AABBMin.x, yWorld, zWorld);
    float3 dir  = float3(1,0,0);

    uint hit = 0;
    [loop]
    for (uint t = 0; t < _TriangleCount; ++t) {
        float3 v0 = _TriangleVerts[t*3 + 0];
        float3 v1 = _TriangleVerts[t*3 + 1];
        float3 v2 = _TriangleVerts[t*3 + 2];
        if (RayTriangleIntersect(orig, dir, v0, v1, v2)) {
            hit = 1;
            break;
        }
    }
    _ProjYZ[uint2(y, z)] = hit;
}

[numthreads(8,8,1)]
void CS_ProjectY(uint3 id : SV_DispatchThreadID)
{
    // id.x = x ∈ [0,Nx), id.y = z ∈ [0,Nz)
    int x = id.x;
    int z = id.y;
    float xWorld = lerp(_AABBMin.x, _AABBMax.x, (x + 0.5) / _SplitCount.x);
    float zWorld = lerp(_AABBMin.z, _AABBMax.z, (z + 0.5) / _SplitCount.z);
    float3 orig = float3(xWorld, _AABBMin.y, zWorld);
    float3 dir  = float3(0,1,0);

    uint hit = 0;
    [loop]
    for (uint t = 0; t < _TriangleCount; ++t) {
        float3 v0 = _TriangleVerts[t*3 + 0];
        float3 v1 = _TriangleVerts[t*3 + 1];
        float3 v2 = _TriangleVerts[t*3 + 2];
        if (RayTriangleIntersect(orig, dir, v0, v1, v2)) {
            hit = 1;
            break;
        }
    }
    _ProjXZ[uint2(x, z)] = hit;
}

[numthreads(8,8,1)]
void CS_ProjectZ(uint3 id : SV_DispatchThreadID)
{
    // id.x = x ∈ [0,Nx), id.y = y ∈ [0,Ny)
    int x = id.x;
    int y = id.y;
    float xWorld = lerp(_AABBMin.x, _AABBMax.x, (x + 0.5) / _SplitCount.x);
    float yWorld = lerp(_AABBMin.y, _AABBMax.y, (y + 0.5) / _SplitCount.y);
    float3 orig = float3(xWorld, yWorld, _AABBMin.z);
    float3 dir  = float3(0,0,1);

    uint hit = 0;
    [loop]
    for (uint t = 0; t < _TriangleCount; ++t) {
        float3 v0 = _TriangleVerts[t*3 + 0];
        float3 v1 = _TriangleVerts[t*3 + 1];
        float3 v2 = _TriangleVerts[t*3 + 2];
        if (RayTriangleIntersect(orig, dir, v0, v1, v2)) {
            hit = 1;
            break;
        }
    }
    _ProjXY[uint2(x, y)] = hit;
}

[numthreads(8,8,8)]
void CS_Combine(uint3 id : SV_DispatchThreadID)
{
    uint pX = _ProjYZ[uint2(id.y, id.z)];
    uint pY = _ProjXZ[uint2(id.x, id.z)];
    uint pZ = _ProjXY[uint2(id.x, id.y)];
    uint alive = pX & pY & pZ;

    _Volume[id] = alive;
    if (alive != 0)
    {
        // 计算当前体素中心的世界坐标
        float3 gridUV = (float3(id) + 0.5) / _SplitCount;  
        float3 worldPos = lerp(_AABBMin, _AABBMax, gridUV);
        _VoxelPositions.Append(worldPos);
    }
}